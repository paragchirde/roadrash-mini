<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Road Rash 3D - Combat Racer</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        overflow: hidden;
        font-family: "Courier New", monospace;
        background: #000;
      }

      #gameCanvas {
        display: block;
        width: 100vw;
        height: 100vh;
      }

      #hud {
        position: absolute;
        top: 20px;
        left: 20px;
        color: #00ffff;
        font-size: 18px;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        z-index: 10;
        background: rgba(0, 0, 0, 0.5);
        padding: 15px;
        border: 2px solid #00ffff;
        border-radius: 5px;
      }

      #hud div {
        margin-bottom: 5px;
      }

      .ready {
        color: #00ff00;
      }

      .cooldown {
        color: #ff0000;
      }

      #gameOver {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: #ff0000;
        font-size: 48px;
        text-shadow: 3px 3px 6px rgba(0, 0, 0, 1);
        display: none;
        z-index: 20;
        text-align: center;
      }

      #gameOver div:first-child {
        font-size: 64px;
        margin-bottom: 20px;
      }

      #gameOver div:last-child {
        font-size: 24px;
        color: #00ffff;
        margin-top: 10px;
      }

      /* Lobby UI */
      #lobby {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.9);
        border: 2px solid #00ffff;
        padding: 30px;
        text-align: center;
        z-index: 100;
        color: #00ffff;
        min-width: 300px;
      }

      #lobby button {
        background: #00ffff;
        color: #000;
        border: none;
        padding: 10px 20px;
        font-family: "Courier New", monospace;
        font-weight: bold;
        cursor: pointer;
        margin: 10px;
        font-size: 16px;
      }

      #lobby input {
        background: #000;
        border: 1px solid #00ffff;
        color: #00ffff;
        padding: 10px;
        font-family: "Courier New", monospace;
        margin: 10px;
        font-size: 16px;
        width: 200px;
      }

      #lobbyStatus {
        margin-top: 15px;
        color: #ffff00;
      }

      /* Leaderboard */
      #leaderboard {
        position: absolute;
        top: 20px;
        right: 20px;
        background: rgba(0, 0, 0, 0.5);
        border: 1px solid #00ffff;
        padding: 10px;
        color: #00ffff;
        z-index: 10;
        min-width: 200px;
        transition: all 1s ease-in-out;
      }

      #leaderboard.centered {
        top: 50%;
        left: 50%;
        right: auto;
        transform: translate(-50%, -50%);
        width: 500px;
        font-size: 24px;
        background: rgba(0, 0, 0, 0.9);
        border: 2px solid #00ffff;
        padding: 30px;
      }

      #restartBtn {
        display: none;
        margin-top: 20px;
        background: #00ff00;
        color: #000;
        border: none;
        padding: 10px 20px;
        font-size: 20px;
        cursor: pointer;
        width: 100%;
        font-family: "Courier New", monospace;
        font-weight: bold;
      }

      .player-label {
        position: absolute;
        color: #00ffff;
        background: rgba(0, 0, 0, 0.7);
        padding: 2px 5px;
        border-radius: 3px;
        font-size: 12px;
        pointer-events: none;
        transform: translate(-50%, -100%);
      }

      /* F1 Timer Style */
      #timerContainer {
        position: absolute;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: #000;
        border: 2px solid #fff;
        padding: 10px 20px;
        z-index: 10;
        text-align: center;
        border-radius: 10px;
        box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
      }

      #timerLabel {
        color: #fff;
        font-size: 14px;
        letter-spacing: 2px;
        margin-bottom: 5px;
      }

      #timerDisplay {
        color: #ff0000;
        font-size: 48px;
        font-weight: bold;
        font-family: "Arial Black", sans-serif;
        text-shadow: 0 0 10px #ff0000;
      }

      /* Highlighted Leaderboard */
      .leaderboard-item {
        padding: 5px;
        border-bottom: 1px solid rgba(0, 255, 255, 0.3);
      }
      .leaderboard-item.highlight {
        background: rgba(0, 255, 255, 0.3);
        font-weight: bold;
        color: #ffffff;
      }
      .leaderboard-item.winner {
        color: #ffff00;
        text-shadow: 0 0 5px #ffff00;
      }

      .badge {
        font-size: 10px;
        padding: 2px 4px;
        border-radius: 3px;
        margin: 0 5px;
        font-weight: bold;
        display: inline-block;
        vertical-align: middle;
      }
      .badge.crash {
        background: #ff0000;
        color: #fff;
      }
      .badge.race {
        background: #00ff00;
        color: #000;
      }
      .badge.finish {
        background: #ffff00;
        color: #000;
      }
    </style>
  </head>
  <body>
    <div id="timerContainer" style="display: none">
      <div id="timerLabel">TIME REMAINING</div>
      <div id="timerDisplay">60</div>
    </div>

    <div id="lobby">
      <h2>MULTIPLAYER LOBBY</h2>
      <input
        type="text"
        id="playerNameInput"
        placeholder="Enter Your Name"
        maxlength="10"
      />
      <br />
      <button id="createBtn">Create Room</button>
      <br />
      <input type="text" id="roomIdInput" placeholder="Enter Room ID" />
      <button id="joinBtn">Join Room</button>
      <br />
      <button
        id="startBtn"
        style="
          display: none;
          background: #00ff00;
          color: #000;
          margin-top: 20px;
        "
      >
        START GAME
      </button>
      <div id="lobbyStatus">Waiting for action...</div>
    </div>

    <div id="leaderboard">
      <h3>LEADERBOARD</h3>
      <div id="leaderboardList"></div>
      <button id="restartBtn">RESTART GAME</button>
    </div>

    <div id="hud">
      <div>SPEED: <span id="speed">0</span> km/h</div>
      <div>DISTANCE: <span id="distance">0</span> m</div>
      <div>ENEMIES HIT: <span id="hits">0</span></div>
      <div>KICK: <span id="kickStatus" class="ready">READY</span></div>
      <div id="roomHud" style="display: none; color: #ffff00; margin-top: 10px">
        ROOM: <span id="roomIdDisplay"></span>
      </div>
    </div>

    <div id="gameOver">
      <div>GAME OVER</div>
      <div>TIME'S UP!</div>
      <div>Final Distance: <span id="finalDistance">0</span> m</div>
      <div>Press R to Restart</div>
    </div>

    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
      }
    </script>
    <script type="module">
      import * as THREE from "three";
      import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
      import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
      import { UnrealBloomPass } from "three/addons/postprocessing/UnrealBloomPass.js";

      // Network State
      const network = {
        peer: null,
        connections: [], // Array of connections (for Host)
        conn: null, // Single connection (for Client)
        isHost: false,
        id: null,
        name: "Player",
        status: "RACING",
        otherPlayers: {}, // { id: { mesh: THREE.Group, targetX: 0, targetZ: 0, distance: 0, label: HTMLElement, name: String } }
        lastUpdate: 0,
      };

      // Clear Room ID on load
      localStorage.removeItem("road_rash_room_id");

      // Lobby Logic
      const lobby = document.getElementById("lobby");
      const status = document.getElementById("lobbyStatus");
      const createBtn = document.getElementById("createBtn");
      const joinBtn = document.getElementById("joinBtn");
      const roomIdInput = document.getElementById("roomIdInput");
      const playerNameInput = document.getElementById("playerNameInput");
      const startBtn = document.getElementById("startBtn");
      const restartBtn = document.getElementById("restartBtn");

      startBtn.addEventListener("click", () => {
        if (network.isHost) {
          startGame();
          // Broadcast Start
          network.connections.forEach((conn) => {
            if (conn.open) conn.send({ type: "START_GAME" });
          });
        }
      });

      restartBtn.addEventListener("click", () => {
        restartGame();
        // Broadcast Reset
        network.connections.forEach((conn) => {
          if (conn.open) conn.send({ type: "RESET_GAME" });
        });
      });

      function startGame() {
        lobby.style.display = "none";
        document.getElementById("timerContainer").style.display = "block";
        gameState.started = true;
        network.status = "RACING";
        startTimer();
      }

      function startTimer() {
        const timerInterval = setInterval(() => {
          if (gameState.gameOver) {
            clearInterval(timerInterval);
            return;
          }
          gameState.timer--;
          document.getElementById("timerDisplay").textContent = gameState.timer;

          if (gameState.timer <= 10) {
            document.getElementById("timerDisplay").style.color = "#ff0000";
          } else {
            document.getElementById("timerDisplay").style.color = "#00ff00";
          }

          if (gameState.timer <= 0) {
            clearInterval(timerInterval);
            gameState.finishing = true;
            spawnFinishLine();
          }
        }, 1000);
      }

      let finishLine = null;
      function spawnFinishLine() {
        const group = new THREE.Group();

        // Checkered Banner
        const textureSize = 64;
        const canvas = document.createElement("canvas");
        canvas.width = textureSize;
        canvas.height = textureSize;
        const ctx = canvas.getContext("2d");
        ctx.fillStyle = "#ffffff";
        ctx.fillRect(0, 0, textureSize, textureSize);
        ctx.fillStyle = "#000000";
        ctx.fillRect(0, 0, textureSize / 2, textureSize / 2);
        ctx.fillRect(
          textureSize / 2,
          textureSize / 2,
          textureSize / 2,
          textureSize / 2
        );

        const texture = new THREE.CanvasTexture(canvas);
        texture.wrapS = THREE.RepeatWrapping;
        texture.wrapT = THREE.RepeatWrapping;
        texture.repeat.set(10, 2);

        const bannerGeo = new THREE.PlaneGeometry(30, 4);
        const bannerMat = new THREE.MeshBasicMaterial({
          map: texture,
          side: THREE.DoubleSide,
        });
        const banner = new THREE.Mesh(bannerGeo, bannerMat);
        banner.position.y = 4;
        group.add(banner);

        // Poles
        const poleGeo = new THREE.CylinderGeometry(0.2, 0.2, 8);
        const poleMat = new THREE.MeshBasicMaterial({ color: 0x888888 });

        const leftPole = new THREE.Mesh(poleGeo, poleMat);
        leftPole.position.set(-15, 2, 0);
        group.add(leftPole);

        const rightPole = new THREE.Mesh(poleGeo, poleMat);
        rightPole.position.set(15, 2, 0);
        group.add(rightPole);

        // "FINISH" Text (Simple Box for now)
        const textGeo = new THREE.BoxGeometry(10, 2, 0.5);
        const textMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
        const textMesh = new THREE.Mesh(textGeo, textMat);
        textMesh.position.y = 6;
        group.add(textMesh);

        // Spawn far ahead
        group.position.set(0, 0, -200);
        scene.add(group);
        finishLine = group;
      }

      function finishGame() {
        gameState.gameOver = true;
        gameState.started = false;
        network.status = "FINISHED";
        document.getElementById("timerContainer").style.display = "none";

        // Move Leaderboard
        const lb = document.getElementById("leaderboard");
        lb.classList.add("centered");

        // Show Restart Button for Host
        if (network.isHost) {
          document.getElementById("restartBtn").style.display = "block";
        }
      }

      function generateId() {
        return Math.random().toString(36).substring(2, 6).toUpperCase();
      }

      createBtn.addEventListener("click", () => {
        const name = playerNameInput.value.trim();
        if (!name) {
          status.textContent = "Please enter your name";
          return;
        }
        network.name = name;
        const id = generateId();
        network.isHost = true;
        initPeer(id);
      });

      joinBtn.addEventListener("click", () => {
        const name = playerNameInput.value.trim();
        if (!name) {
          status.textContent = "Please enter your name";
          return;
        }
        network.name = name;
        const id = roomIdInput.value.toUpperCase();
        if (id.length === 4) {
          network.isHost = false;
          initPeer(null, id);
        } else {
          status.textContent = "Invalid Room ID";
        }
      });

      function initPeer(id, hostIdToConnect) {
        status.textContent = "Initializing Peer...";
        network.peer = new Peer(id);

        network.peer.on("open", (myId) => {
          network.id = myId;
          status.textContent = `Connected! ID: ${myId}`;

          if (network.isHost) {
            status.textContent += " (HOST) - Waiting for players...";
            startBtn.style.display = "inline-block";

            // Show Room ID in HUD
            const roomDisplay = document.getElementById("roomIdDisplay");
            const roomHud = document.getElementById("roomHud");
            roomDisplay.textContent = myId;
            roomHud.style.display = "block";

            // Store in localStorage
            localStorage.setItem("road_rash_room_id", myId);
          } else {
            status.textContent += ` - Connecting to ${hostIdToConnect}...`;
            const conn = network.peer.connect(hostIdToConnect);
            setupConnection(conn);

            // Show Joined Room ID
            const roomDisplay = document.getElementById("roomIdDisplay");
            const roomHud = document.getElementById("roomHud");
            roomDisplay.textContent = hostIdToConnect;
            roomHud.style.display = "block";
          }
        });

        network.peer.on("connection", (conn) => {
          if (network.isHost) {
            setupConnection(conn);
          }
        });

        network.peer.on("error", (err) => {
          status.textContent = "Error: " + err.type;
        });
      }

      function setupConnection(conn) {
        if (network.isHost) {
          network.connections.push(conn);
        } else {
          network.conn = conn;
        }

        conn.on("open", () => {
          console.log("Connection established!");
          if (!network.isHost) {
            status.textContent = "Connected! Waiting for Host to start...";
          }
        });

        conn.on("data", (data) => {
          handleNetworkData(data);
        });
      }

      function handleNetworkData(data) {
        if (data.type === "START_GAME") {
          startGame();
        } else if (data.type === "RESET_GAME") {
          restartGame();
        } else if (data.type === "UPDATE") {
          // Update other player position
          if (!network.otherPlayers[data.id]) {
            createNetworkPlayer(data.id, data.name);
          }
          const p = network.otherPlayers[data.id];
          p.targetX = data.x;
          p.targetZ = data.z;
          p.distance = data.distance;
          p.hits = data.hits;
          p.status = data.status;
          if (data.name) {
            p.name = data.name;
            p.label.textContent = data.name;
          }
        } else if (data.type === "LEADERBOARD") {
          updateLeaderboardUI(data.list);
        }
      }

      function createNetworkPlayer(id, name) {
        const bike = createBike(0x0000ff); // Blue for network players
        bike.position.set(0, 0, 0);
        scene.add(bike);

        // Create Label
        const label = document.createElement("div");
        label.className = "player-label";
        label.textContent = name || `Player ${id}`;
        document.body.appendChild(label);

        network.otherPlayers[id] = {
          mesh: bike,
          targetX: 0,
          targetZ: 0,
          distance: 0,
          label: label,
          name: name || `Player ${id}`,
        };
      }

      // Game State
      const gameState = {
        started: false,
        timer: 60,
        finishing: false,
        speed: 0,
        maxSpeed: 150,
        acceleration: 0.1,
        friction: 0.05,
        braking: 0.3,
        distance: 0,
        enemiesHit: 0,
        kickCooldown: 0,
        kickCooldownMax: 30,
        gameOver: false,
        playerHealth: 3,
        roadCurvature: 0,
        targetCurvature: 0,
        curveTimer: 0,
        cameraShake: 0,
      };

      // Input State
      const keys = {
        left: false,
        right: false,
        up: false,
        down: false,
        space: false,
      };

      // Scene Setup
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x000000);
      scene.fog = new THREE.Fog(0x000000, 10, 100);

      // Camera Setup
      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      camera.position.set(0, 5, 10);
      camera.lookAt(0, 0, -10);

      // Renderer Setup
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      document.body.appendChild(renderer.domElement);

      // Post-Processing
      const renderScene = new RenderPass(scene, camera);
      const bloomPass = new UnrealBloomPass(
        new THREE.Vector2(window.innerWidth, window.innerHeight),
        1.5, // strength
        0.4, // radius
        0.1 // threshold
      );

      const composer = new EffectComposer(renderer);
      composer.addPass(renderScene);
      composer.addPass(bloomPass);

      // Lighting
      const ambientLight = new THREE.AmbientLight(0x404040, 2);
      scene.add(ambientLight);

      const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
      directionalLight.position.set(5, 10, 5);
      directionalLight.castShadow = true;
      directionalLight.shadow.camera.left = -50;
      directionalLight.shadow.camera.right = 50;
      directionalLight.shadow.camera.top = 50;
      directionalLight.shadow.camera.bottom = -50;
      scene.add(directionalLight);

      // Create Bike Function
      function createBike(color) {
        const bike = new THREE.Group();
        const neonMaterial = new THREE.LineBasicMaterial({ color: color });
        const blackMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });

        // Main body
        const bodyGeometry = new THREE.BoxGeometry(1, 0.5, 2);
        const body = new THREE.Mesh(bodyGeometry, blackMaterial);
        const bodyEdges = new THREE.EdgesGeometry(bodyGeometry);
        const bodyLines = new THREE.LineSegments(bodyEdges, neonMaterial);
        body.add(bodyLines);
        bike.add(body);

        // Handlebars
        const handleGeometry = new THREE.BoxGeometry(1.2, 0.1, 0.1);
        const handle = new THREE.Mesh(handleGeometry, blackMaterial);
        const handleEdges = new THREE.EdgesGeometry(handleGeometry);
        const handleLines = new THREE.LineSegments(handleEdges, neonMaterial);
        handle.add(handleLines);
        handle.position.set(0, 0.3, -0.7);
        bike.add(handle);

        // Wheels
        const wheelGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.2, 16);
        wheelGeometry.rotateZ(Math.PI / 2);

        const wheelEdges = new THREE.EdgesGeometry(wheelGeometry);
        const wheelLines = new THREE.LineSegments(wheelEdges, neonMaterial);

        const frontWheel = new THREE.Group();
        const frontWheelMesh = new THREE.Mesh(wheelGeometry, blackMaterial);
        frontWheel.add(frontWheelMesh);
        frontWheel.add(wheelLines.clone());
        frontWheel.position.set(0, -0.3, -0.8);
        bike.add(frontWheel);

        const backWheel = new THREE.Group();
        const backWheelMesh = new THREE.Mesh(wheelGeometry, blackMaterial);
        backWheel.add(backWheelMesh);
        backWheel.add(wheelLines.clone());
        backWheel.position.set(0, -0.3, 0.8);
        bike.add(backWheel);

        bike.userData.wheels = [frontWheel, backWheel];
        bike.userData.originalColor = color;
        bike.userData.bodyLines = bodyLines;
        bike.userData.body = body;

        return bike;
      }

      // Create Player
      const player = createBike(0x00ffff);
      player.position.set(0, 0, 0);
      scene.add(player);

      // Traffic Cars
      const trafficCars = [];
      const maxTraffic = 3;

      function createCar() {
        const carGroup = new THREE.Group();
        const neonMaterial = new THREE.LineBasicMaterial({ color: 0xffff00 }); // Neon Yellow
        const blackMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });

        // Body (Lower)
        const bodyGeo = new THREE.BoxGeometry(2, 0.8, 4);
        const bodyMesh = new THREE.Mesh(bodyGeo, blackMaterial);
        const bodyEdges = new THREE.EdgesGeometry(bodyGeo);
        const bodyLines = new THREE.LineSegments(bodyEdges, neonMaterial);
        bodyMesh.add(bodyLines);
        bodyMesh.position.y = 0.4;
        carGroup.add(bodyMesh);

        // Cabin (Upper)
        const cabinGeo = new THREE.BoxGeometry(1.8, 0.6, 2);
        const cabinMesh = new THREE.Mesh(cabinGeo, blackMaterial);
        const cabinEdges = new THREE.EdgesGeometry(cabinGeo);
        const cabinLines = new THREE.LineSegments(cabinEdges, neonMaterial);
        cabinMesh.add(cabinLines);
        cabinMesh.position.y = 1.1;
        carGroup.add(cabinMesh);

        return carGroup;
      }

      function spawnTrafficCar() {
        const car = createCar();
        const lane = (Math.random() > 0.5 ? 1 : -1) * 5; // Left (-5) or Right (+5)
        const z = -100 - Math.random() * 200; // Spawn far ahead

        car.position.set(lane, 0, z);
        car.userData.lane = lane;
        car.userData.speed = 0.1 + Math.random() * 0.1; // Slower traffic speed

        scene.add(car);
        trafficCars.push(car);
      }

      // Spawn initial traffic
      for (let i = 0; i < maxTraffic; i++) {
        spawnTrafficCar();
      }

      // Enemies Array
      const enemies = [];
      const maxEnemies = 5;

      function spawnEnemy() {
        const enemy = createBike(0xff00ff);
        
        // Requirement 1: Continuous Random Spawning
        const roadWidth = 20;
        let x = (Math.random() - 0.5) * roadWidth * 0.8;

        // Constraint: Avoid overlapping with Traffic Cars
        let overlap = false;
        trafficCars.forEach(car => {
            // Check if car is roughly in the same Z zone where we spawn (-30 to -80)
            // and if X is too close
            if (car.position.z < -20 && Math.abs(car.position.x - x) < 3) {
                overlap = true;
            }
        });

        if (overlap) {
            // Try to shift to the other side
            x = x > 0 ? x - 5 : x + 5;
        }

        // Clamp to road
        if (x < -9) x = -9;
        if (x > 9) x = 9;

        enemy.position.set(x, 0, -30 - Math.random() * 50);
        enemy.userData.velocity = 0.1 + Math.random() * 0.1;
        enemy.userData.hit = false;
        
        // Requirement 3: Weaving Parameters
        enemy.userData.weaveOffset = Math.random() * 100;
        enemy.userData.weaveSpeed = 0.002 + Math.random() * 0.002;

        scene.add(enemy);
        enemies.push(enemy);
      }

      // Spawn initial enemies
      for (let i = 0; i < maxEnemies; i++) {
        spawnEnemy();
      }

      // Obstacles Array
      const obstacles = [];
      const maxObstacles = 15;

      function spawnObstacle() {
        const type = Math.random() > 0.85 ? "rock" : "tree"; // Reduced rock frequency (15%)
        let mesh;
        const blackMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });

        if (type === "rock") {
          // Requirement 2: Rocks
          const geometry = new THREE.DodecahedronGeometry(0.5);
          const base = new THREE.Mesh(geometry, blackMaterial);
          const edges = new THREE.EdgesGeometry(geometry);
          const lineMat = new THREE.LineBasicMaterial({ color: 0xff4500 }); // OrangeRed
          const lines = new THREE.LineSegments(edges, lineMat);
          base.add(lines);
          mesh = base;
          mesh.userData.isRock = true;
        } else {
          mesh = new THREE.Group();
          const neonMaterial = new THREE.LineBasicMaterial({ color: 0xffff00 });

          // Trunk
          const trunkGeometry = new THREE.CylinderGeometry(0.2, 0.3, 2, 8);
          const trunkBase = new THREE.Mesh(trunkGeometry, blackMaterial);
          const trunkEdges = new THREE.EdgesGeometry(trunkGeometry);
          const trunkLines = new THREE.LineSegments(trunkEdges, neonMaterial);
          trunkBase.add(trunkLines);
          mesh.add(trunkBase);

          // Leaves
          const leavesGeometry = new THREE.IcosahedronGeometry(0.8, 1);
          const leavesBase = new THREE.Mesh(leavesGeometry, blackMaterial);
          const leavesEdges = new THREE.EdgesGeometry(leavesGeometry);
          const leavesLines = new THREE.LineSegments(leavesEdges, neonMaterial);
          leavesBase.add(leavesLines);
          leavesBase.position.y = 1.5;
          mesh.add(leavesBase);
          
          mesh.userData.isRock = false;
        }

        let x = 0;
        if (type === "rock") {
            // Requirement 2: Block safe lanes
            // Check where traffic is
            let leftBlocked = false;
            let rightBlocked = false;
            
            trafficCars.forEach(car => {
                if (car.position.z < -10 && car.position.z > -100) {
                    if (car.position.x < -2) leftBlocked = true;
                    if (car.position.x > 2) rightBlocked = true;
                }
            });

            if (leftBlocked && !rightBlocked) {
                x = 4 + Math.random() * 2; // Block right
            } else if (!leftBlocked && rightBlocked) {
                x = -4 - Math.random() * 2; // Block left
            } else {
                x = (Math.random() - 0.5) * 10; // Random center
            }
        } else {
            // Trees on side
            const side = Math.random() > 0.5 ? 1 : -1;
            x = side * (6 + Math.random() * 4);
        }

        mesh.position.set(
          x,
          type === "rock" ? 0.5 : 1,
          -30 - Math.random() * 70
        );
        mesh.castShadow = true;
        mesh.userData.type = type;
        scene.add(mesh);
        obstacles.push(mesh);
      }

      // Spawn initial obstacles
      for (let i = 0; i < maxObstacles; i++) {
        spawnObstacle();
      }



      // Create Road
      const roadSegments = [];
      const segmentCount = 40;
      const segmentLength = 5;
      const roadWidth = 20;

      function createRoadSegment() {
        const group = new THREE.Group();

        // Grid floor
        const roadGeometry = new THREE.PlaneGeometry(
          roadWidth,
          segmentLength,
          3,
          1
        );
        const roadMaterial = new THREE.MeshBasicMaterial({
          color: 0x0000ff, // Neon Blue/Purple
          wireframe: true,
        });
        const road = new THREE.Mesh(roadGeometry, roadMaterial);
        road.rotation.x = -Math.PI / 2;

        // Center line
        const lineGeometry = new THREE.PlaneGeometry(0.1, segmentLength);
        const lineMaterial = new THREE.MeshBasicMaterial({
          color: 0xffff00,
        });
        const centerLine = new THREE.Mesh(lineGeometry, lineMaterial);
        centerLine.rotation.x = -Math.PI / 2;
        centerLine.position.y = 0.01;

        group.add(road);
        group.add(centerLine);

        return group;
      }

      // Initialize road segments
      for (let i = 0; i < segmentCount; i++) {
        const segment = createRoadSegment();
        segment.userData.worldZ = -i * segmentLength;
        segment.position.set(0, -0.5, -i * segmentLength);
        roadSegments.push(segment);
        scene.add(segment);
      }

      // Input Handlers
      document.addEventListener("keydown", (e) => {
        if (e.key === "ArrowLeft") keys.left = true;
        if (e.key === "ArrowRight") keys.right = true;
        if (e.key === "ArrowUp") keys.up = true;
        if (e.key === "ArrowDown") keys.down = true;
        if (e.key === " ") {
          e.preventDefault();
          keys.space = true;
        }
        if (e.key === "r" || e.key === "R") {
          if (gameState.gameOver) restartGame();
        }
      });

      document.addEventListener("keyup", (e) => {
        if (e.key === "ArrowLeft") keys.left = false;
        if (e.key === "ArrowRight") keys.right = false;
        if (e.key === "ArrowUp") keys.up = false;
        if (e.key === "ArrowDown") keys.down = false;
        if (e.key === " ") keys.space = false;
      });

      // Handle Player Input
      function handleInput() {
        if (!gameState.started || gameState.gameOver) return;

        // Lateral movement
        const moveSpeed = 0.15;
        if (keys.left && player.position.x > -6) {
          player.position.x -= moveSpeed;
        }
        if (keys.right && player.position.x < 6) {
          player.position.x += moveSpeed;
        }

        // Attack
        if (keys.space && gameState.kickCooldown === 0) {
          performKick();
          gameState.kickCooldown = gameState.kickCooldownMax;
        }

        // Update cooldown
        if (gameState.kickCooldown > 0) {
          gameState.kickCooldown--;
        }
      }

      // Perform Kick Attack
      function performKick() {
        const kickRange = 3;
        const kickDistance = 5;

        enemies.forEach((enemy) => {
          const dx = Math.abs(enemy.position.x - player.position.x);
          const dz = Math.abs(enemy.position.z - player.position.z);

          if (dx < kickRange && dz < kickDistance && !enemy.userData.hit) {
            // Push enemy sideways
            const pushDirection = enemy.position.x > player.position.x ? 1 : -1;
            enemy.userData.pushVelocity = pushDirection * 0.3;

            // Flash effect
            const originalColor = enemy.userData.originalColor;
            enemy.userData.bodyLines.material.color.setHex(0xffffff);
            setTimeout(() => {
              enemy.userData.bodyLines.material.color.setHex(originalColor);
            }, 100);

            enemy.userData.hit = true;
            gameState.enemiesHit++;
          }
        });
      }

      // Update Environment
      function updateEnvironment() {
        if (!gameState.started || gameState.gameOver) return;

        // Camera Shake Logic
        if (gameState.cameraShake > 0) {
            camera.position.x = (Math.random() - 0.5) * gameState.cameraShake;
            camera.position.y = 5 + (Math.random() - 0.5) * gameState.cameraShake;
            gameState.cameraShake *= 0.9; // Decay
            if (gameState.cameraShake < 0.1) {
                gameState.cameraShake = 0;
                camera.position.set(0, 5, 10); // Reset
            }
        }

        // Physics Logic
        if (keys.up) {
          gameState.speed += gameState.acceleration;
        } else if (keys.down) {
          gameState.speed -= gameState.braking;
        } else {
          gameState.speed -= gameState.friction;
        }

        // Clamp speed
        if (gameState.speed < 0) gameState.speed = 0;
        if (gameState.speed > gameState.maxSpeed)
          gameState.speed = gameState.maxSpeed;

        const speedFactor = gameState.speed / 60;
        gameState.distance += gameState.speed * 0.01;

        // Move Finish Line
        if (gameState.finishing && finishLine) {
          finishLine.position.z += speedFactor;
          if (finishLine.position.z > player.position.z) {
            finishGame();
          }
        }

        // Move road segments
        roadSegments.forEach((segment) => {
          // Move segment towards camera
          segment.position.z += speedFactor;

          // Recycle segment
          if (segment.position.z > 10) {
            segment.userData.worldZ -= segmentCount * segmentLength;
            segment.position.z -= segmentCount * segmentLength;
          }

          segment.position.x = 0;
        });

        // Rotate wheels
        const wheelRotation = speedFactor * 0.2;
        player.userData.wheels.forEach((wheel) => {
          wheel.rotation.x -= wheelRotation;
        });

        // Update enemies
        enemies.forEach((enemy, index) => {
          enemy.position.z += speedFactor + enemy.userData.velocity;

          // Requirement 3: Weaving AI
          const time = Date.now();
          const weave = Math.sin(time * enemy.userData.weaveSpeed + enemy.userData.weaveOffset) * 0.05;
          enemy.position.x += weave;

          // Clamp to road
          if (enemy.position.x < -9) enemy.position.x = -9;
          if (enemy.position.x > 9) enemy.position.x = 9;

          // Apply push velocity
          if (enemy.userData.pushVelocity) {
            enemy.position.x += enemy.userData.pushVelocity;
            enemy.userData.pushVelocity *= 0.95;
            if (Math.abs(enemy.userData.pushVelocity) < 0.01) {
              enemy.userData.pushVelocity = 0;
            }
          }

          // Rotate enemy wheels
          enemy.userData.wheels.forEach((wheel) => {
            wheel.rotation.x -= wheelRotation;
          });

          // Check collision with player
          const dx = Math.abs(enemy.position.x - player.position.x);
          const dz = Math.abs(enemy.position.z - player.position.z);
          if (dx < 1 && dz < 2 && !enemy.userData.collided) {
            enemy.userData.collided = true;
            gameState.speed *= 0.7; // Slow down on collision
          }

          // Respawn if behind camera
          if (enemy.position.z > 10) {
            const roadWidth = 20;
            let x = (Math.random() - 0.5) * roadWidth * 0.8;
            
            // Avoid traffic overlap
            let overlap = false;
            trafficCars.forEach(car => {
                if (car.position.z < -20 && Math.abs(car.position.x - x) < 3) {
                    overlap = true;
                }
            });
            if (overlap) x = x > 0 ? x - 5 : x + 5;
            if (x < -9) x = -9;
            if (x > 9) x = 9;

            enemy.position.set(x, 0, -100 - Math.random() * 50);
            enemy.userData.velocity = 0.1 + Math.random() * 0.1;
            enemy.userData.hit = false;
            enemy.userData.collided = false;
            enemy.userData.pushVelocity = 0;
          }
        });

        // Update obstacles
        obstacles.forEach((obstacle) => {
          obstacle.position.z += speedFactor;

          // Check collision with player
          const dx = Math.abs(obstacle.position.x - player.position.x);
          const dz = Math.abs(obstacle.position.z - player.position.z);
          
          if (dx < 1.5 && dz < 2) {
            if (obstacle.userData.isRock) {
                // Requirement 2: Rock Collision -> Massive Deceleration
                gameState.speed *= 0.1;
                // Trigger controlled camera shake
                gameState.cameraShake = 1.5;
                // Hide rock to prevent multi-collision
                obstacle.position.y = -10;
            } else {
                triggerGameOver();
            }
          }

          // Requirement 3: Enemy Collision with Rocks
          if (obstacle.userData.isRock) {
              enemies.forEach((enemy, eIdx) => {
                  const edx = Math.abs(obstacle.position.x - enemy.position.x);
                  const edz = Math.abs(obstacle.position.z - enemy.position.z);
                  if (edx < 1.5 && edz < 2) {
                      // Enemy Explodes (Remove and Respawn)
                      scene.remove(enemy);
                      enemies.splice(eIdx, 1);
                      spawnEnemy();
                  }
              });
          }

          // Respawn if behind camera
          if (obstacle.position.z > 10) {
            // Find furthest segment
            let lastSegment = roadSegments[0];
            for (let s of roadSegments) {
              if (s.position.z < lastSegment.position.z) lastSegment = s;
            }

            const type = obstacle.userData.type;
            let x = 0;
            
            if (type === "rock") {
                // Block safe lanes logic
                let leftBlocked = false;
                let rightBlocked = false;
                trafficCars.forEach(car => {
                    if (car.position.z < -10 && car.position.z > -100) {
                        if (car.position.x < -2) leftBlocked = true;
                        if (car.position.x > 2) rightBlocked = true;
                    }
                });

                if (leftBlocked && !rightBlocked) x = 5;
                else if (!leftBlocked && rightBlocked) x = -5;
                else x = (Math.random() - 0.5) * 10;
            } else {
                const side = Math.random() > 0.5 ? 1 : -1;
                x = side * (6 + Math.random() * 4);
            }

            obstacle.position.set(
              x,
              type === "rock" ? 0.5 : 1,
              lastSegment.position.z
            );
            // Reset visibility if it was hidden
            if (type === "rock") obstacle.position.y = 0.5;
          }
        });

        // Update Traffic Cars
        trafficCars.forEach((car) => {
          // Move towards player (Oncoming)
          car.position.z += speedFactor + car.userData.speed;

          // Collision Check
          const dx = Math.abs(car.position.x - player.position.x);
          const dz = Math.abs(car.position.z - player.position.z);

          if (dx < 2 && dz < 3) {
            console.log("CRASH WITH CAR");
            gameState.speed = 0;
            triggerGameOver();

            // Camera Shake
            camera.position.x += (Math.random() - 0.5) * 2;
            camera.position.y += (Math.random() - 0.5) * 2;
          }

          // Respawn
          if (car.position.z > 20) {
            // Passed camera
            const z = -200 - Math.random() * 200;
            const lane = (Math.random() > 0.5 ? 1 : -1) * 5;
            car.position.set(lane, 0, z);
            car.userData.lane = lane;
            car.userData.speed = 0.1 + Math.random() * 0.1; // Reset speed
          }
        });
      }

      // Update HUD
      function updateHUD() {
        document.getElementById("speed").textContent = Math.floor(
          gameState.speed
        );
        document.getElementById("distance").textContent = Math.floor(
          gameState.distance
        );
        document.getElementById("hits").textContent = gameState.enemiesHit;

        const kickStatus = document.getElementById("kickStatus");
        if (gameState.kickCooldown > 0) {
          kickStatus.textContent = "COOLDOWN";
          kickStatus.className = "cooldown";
        } else {
          kickStatus.textContent = "READY";
          kickStatus.className = "ready";
        }
      }

      // Game Over
      function triggerGameOver() {
        if (gameState.gameOver) return;
        gameState.gameOver = true;
        network.status = "CRASHED";
        document.getElementById("gameOver").style.display = "block";
        document.getElementById("finalDistance").textContent = Math.floor(
          gameState.distance
        );
      }

      // Restart Game
      function restartGame() {
        gameState.speed = 0;
        gameState.distance = 0;
        gameState.enemiesHit = 0;
        gameState.kickCooldown = 0;
        gameState.gameOver = false;
        gameState.playerHealth = 3;
        gameState.roadCurvature = 0;
        gameState.targetCurvature = 0;
        gameState.timer = 60;
        gameState.started = false;
        gameState.finishing = false;
        network.status = "RACING";

        // Reset Leaderboard UI
        const lb = document.getElementById("leaderboard");
        lb.classList.remove("centered");
        document.getElementById("restartBtn").style.display = "none";

        if (finishLine) {
          scene.remove(finishLine);
          finishLine = null;
        }

        player.position.set(0, 0, 0);

        // Reset road
        for (let i = 0; i < segmentCount; i++) {
          const segment = roadSegments[i];
          segment.userData.worldZ = -i * segmentLength;
          segment.position.set(0, -0.5, -i * segmentLength);
        }

        // Reset enemies
        enemies.forEach((enemy, index) => {
          const lane = (Math.random() > 0.5 ? 1 : -1) * (2 + Math.random() * 2);
          const z = -30 - Math.random() * 50;

          enemy.position.set(lane, 0, z);
          enemy.userData.velocity = 0.1 + Math.random() * 0.1;
          enemy.userData.hit = false;
          enemy.userData.collided = false;
          enemy.userData.pushVelocity = 0;
        });

        // Reset obstacles
        obstacles.forEach((obstacle) => {
          const side = Math.random() > 0.5 ? 1 : -1;
          const type = obstacle.userData.type;
          const z = -30 - Math.random() * 70;

          obstacle.position.set(
            side * (5 + Math.random() * 3),
            type === "rock" ? 0.5 : 1,
            z
          );
        });

        // Reset Traffic
        trafficCars.forEach((car) => {
          const z = -100 - Math.random() * 200;
          const lane = (Math.random() > 0.5 ? 1 : -1) * 5;
          car.position.set(lane, 0, z);
          car.userData.lane = lane;
          car.userData.speed = 0.1 + Math.random() * 0.1;
        });

        document.getElementById("gameOver").style.display = "none";

        // Show Lobby again
        lobby.style.display = "block";
        if (network.isHost) {
          startBtn.style.display = "inline-block";
          status.textContent = "Host - Waiting to Start...";
        } else {
          startBtn.style.display = "none";
          status.textContent = "Waiting for Host to start...";
        }
      }

      // Window Resize Handler
      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      // Game Loop
      function animate() {
        requestAnimationFrame(animate);

        handleInput();
        updateEnvironment();
        updateHUD();
        updateNetwork();

        composer.render();
      }

      function updateNetwork() {
        // Send my position
        const now = Date.now();
        if (network.id && now - network.lastUpdate > 50) {
          const data = {
            type: "UPDATE",
            id: network.id,
            name: network.name,
            x: player.position.x,
            z: player.position.z,
            distance: gameState.distance,
            hits: gameState.enemiesHit,
            status: network.status,
          };

          if (network.isHost) {
            // Host: Broadcast to all clients
            network.connections.forEach((conn) => {
              if (conn.open) conn.send(data);
            });

            // Host: Calculate and Broadcast Leaderboard
            const list = [
              {
                id: network.name,
                dist: Math.floor(gameState.distance),
                hits: gameState.enemiesHit,
                status: network.status,
              },
            ];
            Object.keys(network.otherPlayers).forEach((id) => {
              list.push({
                id: network.otherPlayers[id].name,
                dist: Math.floor(network.otherPlayers[id].distance),
                hits: network.otherPlayers[id].hits || 0,
                status: network.otherPlayers[id].status || "RACING",
              });
            });

            list.sort((a, b) => {
              if (b.hits !== a.hits) return b.hits - a.hits;
              return b.dist - a.dist;
            });

            // Update local UI
            updateLeaderboardUI(list);

            // Send to clients
            const lbData = { type: "LEADERBOARD", list: list };
            network.connections.forEach((conn) => {
              if (conn.open) conn.send(lbData);
            });
          } else {
            // Client: Send to Host
            if (network.conn && network.conn.open) {
              network.conn.send(data);
            }
          }
          network.lastUpdate = now;
        }

        // Update Network Players
        Object.keys(network.otherPlayers).forEach((id) => {
          const p = network.otherPlayers[id];
          // Lerp position
          p.mesh.position.x += (p.targetX - p.mesh.position.x) * 0.1;
          p.mesh.position.z += (p.targetZ - p.mesh.position.z) * 0.1;

          // Update Label Position
          const vector = p.mesh.position.clone();
          vector.y += 2; // Above bike
          vector.project(camera);

          const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
          const y = (-(vector.y * 0.5) + 0.5) * window.innerHeight;

          p.label.style.left = `${x}px`;
          p.label.style.top = `${y}px`;

          // Hide if behind camera
          if (vector.z > 1) {
            p.label.style.display = "none";
          } else {
            p.label.style.display = "block";
          }
        });
      }

      function updateLeaderboardUI(list) {
        const html = list
          .map((p, i) => {
            let classes = "leaderboard-item";
            if (i === 0) classes += " winner";
            if (p.id === network.name) classes += " highlight";

            let statusBadge = "";
            if (p.status === "CRASHED") {
              statusBadge = '<span class="badge crash">CRASHED</span>';
            } else if (p.status === "FINISHED") {
              statusBadge = '<span class="badge finish">FINISHED</span>';
            } else {
              statusBadge = '<span class="badge race">RACING</span>';
            }

            return `<div class="${classes}">
                <span>${i + 1}. ${p.id}</span>
                ${statusBadge}
                <span>[${p.hits} Hits] (${p.dist}m)</span>
            </div>`;
          })
          .join("");
        document.getElementById("leaderboardList").innerHTML = html;
      }

      // Start the game
      animate();
    </script>
  </body>
</html>
